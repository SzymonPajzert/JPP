{-
I do not use coercions, since tuples coincide with parentheses in automatic rule generation
One dimensional tuple is allowed and is treated as syntactic sugar for parentheses.
-}



-- Top definitions of program are separated by semicolon, and consist of:

terminator nonempty TopDef ";" ;
Prog. Program ::= [TopDef] ;

VarDef. TopDef ::= VDef ; -- value definitions
TypDef. TopDef ::= TDef ; -- type specifications (clarifications or new type creations)


-- Token definitions

token UIdent (upper (letter | digit | '_')*) ; -- Word starting with capital letter - type constuctor and types
token LIdent (lower (letter | digit | '_')*) ;
token PIdent '`'(lower)						 ; -- lower letters - type parameters

-- ******************** VALUES ***********************

--- definition of values is syntactic sugar for lambdas - variables are lambdas with 0 arguments
--- pattern matching is available in function definition
--- mulitple definitions of function represent different cases - cases are tried top down

VDef. VDef ::= LIdent [Bind1] "=" Exp ;
-- TODO remove let
VPat. VDef ::= "let"  Bind1   "=" Exp ;
separator nonempty LIdent "" ;

separator nonempty MCase "" ;
EMat. Exp ::= "match" Exp "with" "{" [MCase] "}" ;

MCas. MCase ::= "|" Bind "->" Exp ;

--- Lists and tuples in functional programming
separator Bind "," ;				-- Separator in lists and tuples
BLis.  Bind2 ::= "[" [Bind] "]" ;   -- Bind list elements and its length
BTup.  Bind2 ::= "(" [Bind] ")" ;	-- Bind tuple arguments
BVar.  Bind2 ::= LIdent ;
BInt.  Bind2 ::= Integer ;			-- Bind argument to integer value
BSkip. Bind2 ::= "_" ;				-- Skip argument

separator Bind1 "" ;
BULis. Bind1 ::= Bind2 "::" Bind1 ;  -- Extract head from tail of the list
BCon.  Bind ::= UIdent [Bind1] ;	-- Different from application since during unapplying we want to have full information about parameters
_. Bind ::= Bind1 ;
_. Bind1 ::= Bind2 ;

terminator VDef ";" ;
ELet. Exp ::= "let" "{" [VDef] "}" Exp ;
EIf.  Exp ::= "if" Exp "then" Exp "else" Exp ;
ELam. Exp ::= "fun" [Bind1] "->" Exp ;

ESmal.                  Exp3 ::= Exp4 "<" Exp4 ;
ESmal ([],[1])([],[0]). Exp3 ::= Exp4 ">" Exp4 ;
EEq.                    Exp3 ::= Exp4 "=" Exp4 ;

EAnd. Exp2 ::= Exp2 "&&" Exp3 ;
EOr.  Exp1 ::= Exp1 "||" Exp2 ;

EAdd. Exp1 ::= Exp1 "+" Exp2 ;
ESub. Exp1 ::= Exp1 "-" Exp2 ;
EMul. Exp2 ::= Exp2 "*" Exp3 ;

ECons.Exp3 ::= Exp4 "::" Exp3 ;		 -- List append joins to right

EApp. Exp4 ::= Exp4 Exp5 ;				 -- Function application joins to left

separator Exp "," ;
ELis. Exp5 ::= "[" [Exp] "]" ;
ETup. Exp5 ::= "(" [Exp] ")" ;
EInt. Exp5 ::= Integer ;			 -- Integer literal
ECon. Exp5 ::= UIdent ;					 -- Type constructor
EVar. Exp5 ::= LIdent ;					 -- Identificator call

-- Boolean types are part of language, not hardcoded in its grammar
-- Data constructors are functions, ex:
-- Node : `a -> Node -> Node -> Node
-- Empty : Node

-- coercions

_. Exp  ::= Exp1 ;
_. Exp1 ::= Exp2 ;
_. Exp2 ::= Exp3 ;
_. Exp3 ::= Exp4 ;
_. Exp4 ::= Exp5 ;


-- ************************ TYPES ***********************
separator PIdent "" ;
separator SubType "" ;
separator Type "," ;
separator Type3 "" ;

TDef.  TDef ::= UIdent [PIdent] "=" Type ;
TClar. TDef ::= LIdent ":" Type ;

-- Type is creation of new type - broadening the domain of existing types
TApp. Type2 ::= Type2 Type3;
TBnd. Type3 ::= UIdent;		  -- Call of existing type (at the beginning Int and Bool)
TUnd. Type3 ::= PIdent ;
TTup. Type3 ::= "(" [Type] ")" ;
TLis. Type3 ::= "[" Type2 "]" ;

-- TCon. Type2 ::= UIdent [Type2] ;
TFun. Type2 ::= Type2 "->" Type3 ;		-- Types bind to the right

TCData. Type1 ::= "adt" "{" [SubType] "}" ;


_. Type ::= Type1 ;
_. Type1 ::= Type2 ;
_. Type2 ::= Type3 ;

SubType. SubType ::= "|" UIdent [Type3] ;
-- comments

comment "--" ;
comment "{-" "-}" ;